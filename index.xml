<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Blog</title>
    <link>http://cshung.github.io/</link>
    <description>Recent content on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Jan 2021 12:11:37 -0800</lastBuildDate>
    
	<atom:link href="http://cshung.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How CoreCLR GC understand objects (part 1)</title>
      <link>http://cshung.github.io/posts/gc-objects-1/</link>
      <pubDate>Mon, 04 Jan 2021 12:11:37 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/gc-objects-1/</guid>
      <description>In this series of posts, I am going to explain how the GC understand objects. In this part, we will focus on size.
Why does it matter? The GC expects the heap to be tightly packed with objects. It scans the heap by starting at the beginning of the heap and walk the object one-by-one by this simple algorithm. This is real code excerpt from gc.cpp line 22972 to 23002, out of dotnet/runtime repo, tag v5.</description>
    </item>
    
    <item>
      <title>Hello Reflection</title>
      <link>http://cshung.github.io/posts/hello-reflection/</link>
      <pubDate>Sat, 05 Dec 2020 14:53:55 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/hello-reflection/</guid>
      <description>To get started using ILCompiler.Reflection.ReadyToRun, let&amp;rsquo;s construct a simple HelloWorld project. If you don&amp;rsquo;t know what it is, please take a look at the previous post.
Getting started We will create a .NET Core console application. Create a folder named HelloReflection and invoke dotnet new console.
C:\dev&amp;gt;mkdir HelloReflectionC:\dev&amp;gt;cd HelloReflectionC:\dev\HelloReflection&amp;gt;dotnet new consoleThe template &amp;quot;Console Application&amp;quot; was created successfully.Processing post-creation actions...Running &#39;dotnet restore&#39; on C:\dev\HelloReflection\HelloReflection.csproj...Determining projects to restore.</description>
    </item>
    
    <item>
      <title>Debugging help for CoreCLR GC - Mono</title>
      <link>http://cshung.github.io/posts/coreclrgc-mono/</link>
      <pubDate>Fri, 04 Dec 2020 11:52:15 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/coreclrgc-mono/</guid>
      <description>I was invited to help with debugging an issue in the CoreCLR GC - Mono project. In this blog entry, I am planning to describe the debugging process so that it can be repeated to move the project forward.
What is CoreCLR GC - Mono? CoreCLR GC - Mono is an attempt to use CoreCLR&amp;rsquo;s GC to replace sgen, a simple generational garbage collector for Mono. The major goal of the project is to improve performance.</description>
    </item>
    
    <item>
      <title>Automate WinDBG</title>
      <link>http://cshung.github.io/posts/automate-windbg/</link>
      <pubDate>Mon, 31 Aug 2020 17:01:33 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/automate-windbg/</guid>
      <description>Automate WinDBG WinDBG is a very convenient debugger, but typing the same command again and again is tiresome, especially during startup. GDB provided a mechanism to run some commands on startup through gdbinit. WinDBG has the equivalent, although it is not as clear. In this blog post, I am going to share how I automated WinDBG to run some commands on startup. For the impatient, just rush to the summary to get the commands.</description>
    </item>
    
    <item>
      <title>ILSpy.ReadyToRun</title>
      <link>http://cshung.github.io/posts/ilspy-readytorun/</link>
      <pubDate>Sat, 25 Jul 2020 19:50:22 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/ilspy-readytorun/</guid>
      <description>Introduction ILSpy.ReadyToRun is my side project. It is a plugin in ILSpy that allow us to inspect the precompiled code in a ReadyToRun image. My vision is to make all information available in a ready to run image to be displayed in a human readable manner.
What can it do? If you open a ReadyToRun image in ILSpy, it will show up exactly as it was. You can see all the types, the methods, and the decompiled C# code, as usual.</description>
    </item>
    
    <item>
      <title>Xv6 on v86</title>
      <link>http://cshung.github.io/posts/xv6-on-v86/</link>
      <pubDate>Sun, 28 Jun 2020 09:27:30 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/xv6-on-v86/</guid>
      <description>Xv6 on v86 In this post, I will talk about my journey to get Xv6 running on v86. Xv6 is a unix-like teaching OS developed by MIT. v86 is an x86 virtual machine running on the browser developed by Fabian.
The key characteristic of these two systems is that they are simple compared to their industrial-strength counterparts (compared to the Linux kernel or the QEMU emulator). Being simple, it is easy to understand.</description>
    </item>
    
    <item>
      <title>Introduction to ILCompiler.Reflection.ReadyToRun</title>
      <link>http://cshung.github.io/posts/introduction-to-ilcompiler-reflection-readytorun/</link>
      <pubDate>Thu, 25 Jun 2020 08:08:17 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/introduction-to-ilcompiler-reflection-readytorun/</guid>
      <description>Introduction ILCompiler.Reflection.ReadyToRun.dll is a new library I introduced in late 2019. It is meant to make the data embedded in a ReadyToRun binary available for access.
Background What is ReadyToRun? ReadyToRun is a new native compilation technology for .NET Core. For people who know about NGEN, it can be roughly thought as the .NET Core version of NGEN.
What is native compilation? When a managed language (such as C#) is compiled, it is compiled into an intermediate language named MSIL.</description>
    </item>
    
  </channel>
</rss>