<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Blog</title>
    <link>http://cshung.github.io/</link>
    <description>Recent content on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Jan 2021 13:25:05 -0800</lastBuildDate>
    
	<atom:link href="http://cshung.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Debug Info Debugging</title>
      <link>http://cshung.github.io/posts/debug-info-debugging/</link>
      <pubDate>Mon, 18 Jan 2021 13:25:05 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/debug-info-debugging/</guid>
      <description>Recently, I have found an anomaly in the debug info generated by the ready to run compiler. In this post, I will talk about how I found it and how I debugged it.
Discovery In a routine update of the ILCompiler.Reflection.ReadyToRun.dll for ILSpy, I turned on the STRESS mode I introduced in a recent commit to test whether or not the new version can disassemble all the methods in System.Private.CoreLib. To my surprise, it failed with this exception.</description>
    </item>
    
    <item>
      <title>POH Tuning (Part 1 - What is my pinned object heap size?)</title>
      <link>http://cshung.github.io/posts/poh-tuning-1/</link>
      <pubDate>Fri, 15 Jan 2021 11:18:17 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/poh-tuning-1/</guid>
      <description>In this series, I am going to talk about my work to tune the pinned object heap. The first step to tuning is to understand how it performs now. Unfortunately, the tools for analyzing the performance is incomplete.
Pinned Object Heap size (and the event tracing mechanisms) With the tools available in .NET 5 time frame, we did not know the size of the pinned object heap. We had the information in the trace, but we did not have the parser to understand them.</description>
    </item>
    
    <item>
      <title>Generation Aware Analysis</title>
      <link>http://cshung.github.io/posts/generation-aware-analysis/</link>
      <pubDate>Tue, 05 Jan 2021 14:47:10 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/generation-aware-analysis/</guid>
      <description>The problem? The .NET GC is generational, it makes the assumption that allocations are broadly divided into two classes, either they are short-lived (e.g. temporary objects) or they are long-lived (e.g. constants, caches for repeated uses). This assumption is often true, but once in a while, that&amp;rsquo;s not true, often due to programmer mistakes. If a pile of objects meant for short term usage is leaked into gen2, that can cost a short term spike in ephemeral GC latency, and a long term memory cost for storing them.</description>
    </item>
    
    <item>
      <title>How CoreCLR GC understand objects (part 2)</title>
      <link>http://cshung.github.io/posts/gc-objects-2/</link>
      <pubDate>Mon, 04 Jan 2021 14:14:15 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/gc-objects-2/</guid>
      <description>In addition to size described in an earlier post, it is also important for the GC to know where the pointers are in an object. This is because in the mark phase, we need to traverse the object graph. Here is a function for the mark phase in gc.cpp line 19415-19452.
Where is the code that perform the traversal? //this method assumes that *po is in the [low. high[ range void gc_heap::mark_object_simple (uint8_t** po THREAD_NUMBER_DCL) { uint8_t* o = *po; /* some code that does not change o or po */ if (gc_mark1 (o)) { /* some code that does not change o or po */ { go_through_object_cl (method_table(o), o, s, poo, { uint8_t* oo = *poo; /* some code to recursively mark oo */ } ); } } } Imagine this is run during the mark phase, if we discover an unmarked object, then we traverse into its pointers and recursively mark the objects it points to.</description>
    </item>
    
    <item>
      <title>How CoreCLR GC understand objects (part 1)</title>
      <link>http://cshung.github.io/posts/gc-objects-1/</link>
      <pubDate>Mon, 04 Jan 2021 12:11:37 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/gc-objects-1/</guid>
      <description>In this series of posts, I am going to explain how the GC understand objects. In this part, we will focus on size.
Why does it matter? The GC expects the heap to be tightly packed with objects. It scans the heap by starting at the beginning of the heap and walk the object one-by-one by this simple algorithm. This is real code excerpt from gc.cpp line 22972 to 23002, out of dotnet/runtime repo, tag v5.</description>
    </item>
    
    <item>
      <title>Hello Reflection</title>
      <link>http://cshung.github.io/posts/hello-reflection/</link>
      <pubDate>Sat, 05 Dec 2020 14:53:55 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/hello-reflection/</guid>
      <description>To get started using ILCompiler.Reflection.ReadyToRun, let&amp;rsquo;s construct a simple HelloWorld project. If you don&amp;rsquo;t know what it is, please take a look at the previous post.
Getting started We will create a .NET Core console application. Create a folder named HelloReflection and invoke dotnet new console.
C:\dev&amp;gt;mkdir HelloReflectionC:\dev&amp;gt;cd HelloReflectionC:\dev\HelloReflection&amp;gt;dotnet new consoleThe template &amp;quot;Console Application&amp;quot; was created successfully.Processing post-creation actions...Running &#39;dotnet restore&#39; on C:\dev\HelloReflection\HelloReflection.csproj...Determining projects to restore.</description>
    </item>
    
    <item>
      <title>Debugging help for CoreCLR GC - Mono</title>
      <link>http://cshung.github.io/posts/coreclrgc-mono/</link>
      <pubDate>Fri, 04 Dec 2020 11:52:15 -0800</pubDate>
      
      <guid>http://cshung.github.io/posts/coreclrgc-mono/</guid>
      <description>I was invited to help with debugging an issue in the CoreCLR GC - Mono project. In this blog entry, I am planning to describe the debugging process so that it can be repeated to move the project forward.
What is CoreCLR GC - Mono? CoreCLR GC - Mono is an attempt to use CoreCLR&amp;rsquo;s GC to replace sgen, a simple generational garbage collector for Mono. The major goal of the project is to improve performance.</description>
    </item>
    
    <item>
      <title>Automate WinDBG</title>
      <link>http://cshung.github.io/posts/automate-windbg/</link>
      <pubDate>Mon, 31 Aug 2020 17:01:33 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/automate-windbg/</guid>
      <description>Automate WinDBG WinDBG is a very convenient debugger, but typing the same command again and again is tiresome, especially during startup. GDB provided a mechanism to run some commands on startup through gdbinit. WinDBG has the equivalent, although it is not as clear. In this blog post, I am going to share how I automated WinDBG to run some commands on startup. For the impatient, just rush to the summary to get the commands.</description>
    </item>
    
    <item>
      <title>ILSpy.ReadyToRun</title>
      <link>http://cshung.github.io/posts/ilspy-readytorun/</link>
      <pubDate>Sat, 25 Jul 2020 19:50:22 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/ilspy-readytorun/</guid>
      <description>Introduction ILSpy.ReadyToRun is my side project. It is a plugin in ILSpy that allow us to inspect the precompiled code in a ReadyToRun image. My vision is to make all information available in a ready to run image to be displayed in a human readable manner.
What can it do? If you open a ReadyToRun image in ILSpy, it will show up exactly as it was. You can see all the types, the methods, and the decompiled C# code, as usual.</description>
    </item>
    
    <item>
      <title>Xv6 on v86</title>
      <link>http://cshung.github.io/posts/xv6-on-v86/</link>
      <pubDate>Sun, 28 Jun 2020 09:27:30 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/xv6-on-v86/</guid>
      <description>Xv6 on v86 In this post, I will talk about my journey to get Xv6 running on v86. Xv6 is a unix-like teaching OS developed by MIT. v86 is an x86 virtual machine running on the browser developed by Fabian.
The key characteristic of these two systems is that they are simple compared to their industrial-strength counterparts (compared to the Linux kernel or the QEMU emulator). Being simple, it is easy to understand.</description>
    </item>
    
    <item>
      <title>Introduction to ILCompiler.Reflection.ReadyToRun</title>
      <link>http://cshung.github.io/posts/introduction-to-ilcompiler-reflection-readytorun/</link>
      <pubDate>Thu, 25 Jun 2020 08:08:17 -0700</pubDate>
      
      <guid>http://cshung.github.io/posts/introduction-to-ilcompiler-reflection-readytorun/</guid>
      <description>Introduction ILCompiler.Reflection.ReadyToRun.dll is a new library I introduced in late 2019. It is meant to make the data embedded in a ReadyToRun binary available for access.
Background What is ReadyToRun? ReadyToRun is a new native compilation technology for .NET Core. For people who know about NGEN, it can be roughly thought as the .NET Core version of NGEN.
What is native compilation? When a managed language (such as C#) is compiled, it is compiled into an intermediate language named MSIL.</description>
    </item>
    
  </channel>
</rss>