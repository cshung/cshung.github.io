<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/syntax.css">
    
    
    <title>My Blog | Debug Info Debugging</title>


</head><body class="light-theme"><div id="nav-border" class="container">
    <nav id="nav" class="nav justify-content-center">
        
        <a class="nav-link" href="/">
        
        
        <i data-feather="home"></i> 
        
        
        Home
        </a>
        
        <a class="nav-link" href="/tags/">
        
        
        <i data-feather="tag"></i> 
        
        
        Tags
        </a>
        
        <a class="nav-link" href="#" id="toggleDarkModeButton"><i data-feather="sun"></i></a>
        <span style="padding:5px"><input type="text" id="queryTextField"></span><a class="nav-link" href="#" id="searchButton"><i data-feather="search"></i></a>
    </nav>
</div><div id="content" style="margin:20px">
<h1>Debug Info Debugging</h1>


<i data-feather="calendar"></i>
<time datetime="2021-01-18">Jan 18, 2021</time>

<br><br>
<p>Recently, I have found an anomaly in the debug info generated by the ready to run compiler. In this post, I will talk about how I found it and how I debugged it.</p>
<h1 id="discovery">Discovery</h1>
<p>In a routine update of the <code>ILCompiler.Reflection.ReadyToRun.dll</code> for ILSpy, I turned on the <a href="https://github.com/icsharpcode/ILSpy/blob/0440ffdc06071270a7beee0fbb14c32213f7d9d6/ILSpy.ReadyToRun/ReadyToRunLanguage.cs#L41"><code>STRESS</code></a> mode I introduced in a recent <a href="https://github.com/icsharpcode/ILSpy/commit/cc8dfb925c9cc3f7ffe2b7a7669172badac5240c">commit</a> to test whether or not the new version can disassemble all the methods in <code>System.Private.CoreLib</code>. To my surprise, it failed with this exception.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">An item with the same key has already been added.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mscorlib.dll!System.ThrowHelper.ThrowArgumentException()
</span></span><span class="line"><span class="cl">mscorlib.dll!System.Collections.Generic.Dictionary&lt;...&gt;.Insert(...)	
</span></span><span class="line"><span class="cl">ILSpy.ReadyToRun.Plugin.dll!ICSharpCode.ILSpy.ReadyToRun.ReadyToRunDisassembler.DebugInfoHelper.Update(...) 
</span></span><span class="line"><span class="cl">ILSpy.ReadyToRun.Plugin.dll!ICSharpCode.ILSpy.ReadyToRun.ReadyToRunDisassembler.DecorateDebugInfo(...) 
</span></span><span class="line"><span class="cl">ILSpy.ReadyToRun.Plugin.dll!ICSharpCode.ILSpy.ReadyToRun.ReadyToRunDisassembler.Disassemble(...) 
</span></span><span class="line"><span class="cl">ILSpy.ReadyToRun.Plugin.dll!ICSharpCode.ILSpy.ReadyToRun.ReadyToRunLanguage.DecompileMethod(...)
</span></span></code></pre></div><p>This looks like an implementation bug in <code>DebugInfoHelper.Update</code>. Why is it a compiler problem? It makes sense to start with understanding how <code>DebugInfoHelper</code> works.</p>
<h1 id="debuginfohelper">DebugInfoHelper</h1>
<p>The debug info helper is a data structure used to decorate the disassembly with the mapping between register or register relative memory access to the managed &lsquo;variables&rsquo; such as parameters or local variables. The data structures stored in the ready to run image are in the <a href="https://github.com/dotnet/runtime/blob/69e114c1abf91241a0eeecf1ecceab4711b8aa62/src/coreclr/tools/aot/ILCompiler.Reflection.ReadyToRun/DebugInfoTypes.cs#L16"><code>NativeVarInfo</code></a> format.</p>
<p>The key inconvenience here is the fact that the info is valid only between certain code offsets. For each instruction, we would like to check if there is a matching <code>NativeVarInfo</code>, and because of the fact that these objects are valid only within a bound, the naive solution has to check each of them.</p>
<p>To remedy that, I built <code>DebugInfoHelper</code>. The idea is that we can maintain the hash table we wanted. First, we split each <code>NativeVarInfo</code> into two <code>NativeVarInfoRecord</code>. One of them corresponds to the beginning of the code offset range and the other corresponds to the end of the code offset range. Then we sort them by the code offsets, with the caveat that the end record would precede the start record. Then we can process these records as the code offset goes and maintain the hash table we wanted. An experiment shows that this optimization speed up the lookup significantly.</p>
<p>As a side-effect of this change, if two <code>NativeVarInfo</code> objects happen to describe the same location twice in overlapping code offset ranges, the starting of the later record would find an existing record and therefore fail to add it into the hash table, exactly the error we are seeing.</p>
<p>Therefore, the real bug is that we have a single location being described twice in an overlapping code offset range. R2RDump confirms my hypothesis:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">void System.Runtime.CompilerServices.NullableAttribute..ctor(byte[])
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Debug Info
</span></span><span class="line"><span class="cl">    Bounds:
</span></span><span class="line"><span class="cl">    Native Offset: 0x0, Prolog, Source Types: StackEmpty
</span></span><span class="line"><span class="cl">    Native Offset: 0xA, IL Offset: 0x000d, Source Types: StackEmpty
</span></span><span class="line"><span class="cl">    Native Offset: 0xA, Epilog, Source Types: StackEmpty
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Variable Locations:
</span></span><span class="line"><span class="cl">    Variable Number: 0
</span></span><span class="line"><span class="cl">    Start Offset: 0x0
</span></span><span class="line"><span class="cl">    End Offset: 0x1
</span></span><span class="line"><span class="cl">    Loc Type: VLT_REG
</span></span><span class="line"><span class="cl">    Register: RCX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Variable Number: 1
</span></span><span class="line"><span class="cl">    Start Offset: 0x0
</span></span><span class="line"><span class="cl">    End Offset: 0x1
</span></span><span class="line"><span class="cl">    Loc Type: VLT_REG
</span></span><span class="line"><span class="cl">    Register: RDX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Variable Number: 1
</span></span><span class="line"><span class="cl">    Start Offset: 0x0
</span></span><span class="line"><span class="cl">    End Offset: 0x4
</span></span><span class="line"><span class="cl">    Loc Type: VLT_REG
</span></span><span class="line"><span class="cl">    Register: RDX
</span></span></code></pre></div><p>These will translate to these operations:</p>
<div class="mermaid">
graph TD;
    A[Add RCX to param0 at offset 0]
    B[Add RDX to param1 at offset 0]
    C[Add RDX to param1 at offset 0]
    D[Remove RCX to param0 at offset 1]
    E[Remove RDX to param1 at offset 1]
    F[Remove RDX to param1 at offset 4]
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    style A width:400px
    style B width:400px
    style C width:400px
    style D width:400px
    style E width:400px
    style F width:400px
</div>
<p>And therefore it will fail to insert into the hash table at the third step.</p>
<h1 id="filtering-method-to-compile">Filtering method to compile</h1>
<p>Next, I would like to investigate the compilation to figure out why did we generated these overlapping code offset ranges. To do so, I would like to reproduce the compilation and reduce it to make debugging easier. By capturing the build log, I figure the command to compile <code>System.Private.CoreLib.dll</code> is as follow:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">C:\dev\runtime\dotnet.cmd C:\dev\runtime\artifacts\bin\coreclr\windows.x64.Debug\crossgen2\crossgen2.dll -o:C:\dev\runtime\artifacts\bin\coreclr\windows.x64.Release\System.Private.CoreLib.dll -r:C:\dev\runtime\artifacts\bin\coreclr\windows.x64.Release\IL\*.dll --targetarch:x64 -O C:\dev\runtime\artifacts\bin\coreclr\windows.x64.Release\IL\System.Private.CoreLib.dll --pdb --pdb-path:C:\dev\runtime\artifacts\bin\coreclr\windows.x64.Release\PDB
</span></span></code></pre></div><p>The interesting thing is that the compilation process loads <code>clrjit_win_x64_x64.DLL</code>. This module is the workhorse for compilation. Notice that it also load <code>clrjit.dll</code>. That module is used to support the execution of crossgen2 but not for compiling the target binary. The entry point for compilation is <code>clrjit_win_x64_x64!CILJit::compileMethod</code>. By setting a breakpoint on this method we figure out the following call stack.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">clrjit_win_x64_x64!CILJit::compileMethod(...)
</span></span><span class="line"><span class="cl">jitinterface_x64!JitCompileMethod(...)
</span></span><span class="line"><span class="cl">System_Runtime_InteropServices_RuntimeInformation!ILStubClass.IL_STUB_PInvoke(...)
</span></span><span class="line"><span class="cl">ILCompiler_ReadyToRun!Internal.JitInterface.CorInfoImpl.CompileMethodInternal(...)
</span></span><span class="line"><span class="cl">ILCompiler_ReadyToRun!Internal.JitInterface.CorInfoImpl.CompileMethod(...)
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><p>The last method above is interesting, it includes a filter to detect whether or not to compile code, which allows us to optimize our debugging by compiling just the offending method.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="line"><span class="cl">        <span class="kd">public</span> <span class="k">void</span> <span class="n">CompileMethod</span><span class="p">(</span><span class="n">MethodWithGCInfo</span> <span class="n">methodCodeNodeNeedingCode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">bool</span> <span class="n">codeGotPublished</span> <span class="p">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">_methodCodeNode</span> <span class="p">=</span> <span class="n">methodCodeNodeNeedingCode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(!</span><span class="n">ShouldSkipCompilation</span><span class="p">(</span><span class="n">MethodBeingCompiled</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">MethodSignatureIsUnstable</span><span class="p">(</span><span class="n">MethodBeingCompiled</span><span class="p">.</span><span class="n">Signature</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">MethodIL</span> <span class="n">methodIL</span> <span class="p">=</span> <span class="n">_compilation</span><span class="p">.</span><span class="n">GetMethodIL</span><span class="p">(</span><span class="n">MethodBeingCompiled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">methodIL</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">CompileMethodInternal</span><span class="p">(</span><span class="n">methodCodeNodeNeedingCode</span><span class="p">,</span> <span class="n">methodIL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">codeGotPublished</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">finally</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(!</span><span class="n">codeGotPublished</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">PublishEmptyCode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">CompileMethodCleanup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></div><p>Also, <code>MethodBeingCompiled</code> has a nice <code>ToString()</code> method implementation that gives a human-readable string, which means I can hack the code to compile just the method I wanted right there. After I hacked the code to compile just that method, I checked the R2RDump, it is only that method, and the debug info still has the overlapping code offset ranges.</p>
<h1 id="jitdump">JITDump</h1>
<p>The next step is to enable <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md#reading-a-jitdump">JIT dump</a>. It produces a lot of information. It could be enabled by an environment variable.</p>
<p>The key information in the JIT dump is this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">*************** In genSetScopeInfo()
</span></span><span class="line"><span class="cl">VarLocInfo count is 3
</span></span><span class="line"><span class="cl">; Variable debug info: 3 live range(s), 2 var(s) for method System.Runtime.CompilerServices.NullableAttribute:.ctor(System.Byte[]):this
</span></span><span class="line"><span class="cl">  0(   UNKNOWN) : From 00000000h to 00000001h, in rcx
</span></span><span class="line"><span class="cl">  1(   UNKNOWN) : From 00000000h to 00000001h, in rdx
</span></span><span class="line"><span class="cl">  1(   UNKNOWN) : From 00000000h to 00000004h, in rdx
</span></span></code></pre></div><p>This agrees with our observation in R2RDump, confirming that it is not a decoding issue.</p>
<p>This dump serves as a starting point for me to start exploring the code. Here are my high-level learnings:</p>
<p>At the final phase of the compilation, we generate the code for each basic block. Initially, these instructions are generated into instruction groups. During generation, we create something called scopes. These scopes represent the fact that we have a mapping between a variable and a physical location. The scope remembers the begin and the end code offset within the instruction group. When we have done with the generation, these instruction groups are organized and we generate the actual code offset by adding the offset of the instruction group and the code offset within the instruction group.</p>
<p>As I debugged, I figured we have 3 instruction groups representing the prolog, body, and the epilog. To my surprise, the instruction group offset for the body is 0. I further figure out that the prolog actually has size 0. Turn out the wrong entry is not the last one, instead, it is the two entries above. We shouldn&rsquo;t have generated any debug info for the prolog if the prolog doesn&rsquo;t have a size, but I found this in <code>genSetScopeInfoUsingsiScope</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">        // The range may be 0 if the prolog is empty. For such a case,
</span></span><span class="line"><span class="cl">        // report the liveness of arguments to span at least the first
</span></span><span class="line"><span class="cl">        // instruction in the method. This will be incorrect (except on
</span></span><span class="line"><span class="cl">        // entry to the method) if the very first instruction of the method
</span></span><span class="line"><span class="cl">        // is part of a loop. However, this should happen
</span></span><span class="line"><span class="cl">        // very rarely, and the incorrectness is worth being able to look
</span></span><span class="line"><span class="cl">        // at the argument on entry to the method.
</span></span><span class="line"><span class="cl">        if (startOffs == endOffs)
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            noway_assert(startOffs == 0);
</span></span><span class="line"><span class="cl">            endOffs++;
</span></span><span class="line"><span class="cl">        }
</span></span></code></pre></div><p>When I debugged it, we actually went into the branch, that is why we generated a couple debug variable mappings with just 1 byte. That code was introduced long ago, chances is in my last run of the tests, we don&rsquo;t have a method with 0 sized prolog.</p>
<h1 id="the-fix">The fix</h1>
<p>Now it is obvious that this anomaly is a conscious choice. Now we have to adjust <code>DebugInfoHelper</code>. I worked on multiple approaches and found more interesting details in the debug info. For example, I found that sometimes the compiler is able to map two variables to the same physical location because they should share the same value. They are overlapping ranges in the above sense, but it is not wrong at all. To accommodate for these cases as well, instead of mapping a single location to a single variable, I mapped a single location to multiple variables (duplication allowed), and that solved all the problems listed here. I have submitted a <a href="https://github.com/icsharpcode/ILSpy/pull/2279">PR</a> to ILSpy to get this fixed.</p>


        </div><p class="footer text-center">Copyright (c) 2026 Andrew Au</p><script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true });</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<script src="/js/feather.min.js"></script>
<script src="/index.js"></script>
<script>

  function getCookie(cname) {
    let name = cname + "=";
    let ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }

  function ensureIcon() {
    if (document.body.classList.contains("dark-theme")) {
      toggleDarkModeButton.innerHTML = '<i data-feather="sun"></i>';
    } else {
      toggleDarkModeButton.innerHTML = '<i data-feather="moon"></i>';
    }
    feather.replace();
  }
  function saveCookie() {
    if (document.body.classList.contains("dark-theme")) {
      setCookie("darkMode", "true", 365);
    } else {
      setCookie("darkMode", "false", 365);
    }
  }

  function load(pre) {
    link = pre.getAttribute("data-code-link");
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        pre.className = "prettyprint";
        pre.textContent = xhr.responseText;
      }
      prettyPrint();
    };
    xhr.open('GET', link);
    xhr.send();
  }

  function onSearchButtonClicked(e) {
    e.preventDefault();
    var query = $("#queryTextField").val();
    var terms = query.split(' ');
    
    var result = {};
    for (var i = 0; i < terms.length; ++i) {
      var term = terms[i].toLowerCase();
      if (term in index.Terms)
      {
        for (i = 0; i < index.Terms[term].length; i += 2) {
          var doc = index.Terms[term][i];
          var count = index.Terms[term][i + 1];
          if (doc in result) {
            result[doc] += count;
          } else {
            result[doc] = count;
          }
        }
      }
    }
    
    $("#content").empty();
    for (var key in result) {
      $("#content").append($('<a>', {
        href: index.Documents[key].replace("../../content","").replace(".md",""),
        text: index.Titles[key]
      }));
      $("#content").append($('<br>'));
    }
  }

  $(document).ready(function () {
    var darkMode = getCookie("darkMode");
    if (darkMode == "true") {
      document.body.classList.add("dark-theme");
      document.body.classList.remove("light-theme");
    }
    ensureIcon();

    $("#toggleDarkModeButton").click(function (e) {
      e.preventDefault();
      document.body.classList.toggle("dark-theme");
      document.body.classList.toggle("light-theme");
      saveCookie();
      ensureIcon();
    });

    $("#searchButton").click(onSearchButtonClicked);

    var pres = document.getElementsByTagName("pre");
    for (var i = 0; i < pres.length; ++i) {
      var pre = pres[i];
      if (pre.classList.contains("pretty-github-code")) {
        load(pre);
      }
    }
  });

  $(window).on("load", function () {
    $("body").show();
  });
</script></body>
</html>