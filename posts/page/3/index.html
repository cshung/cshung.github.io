<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/syntax.css">
    
    
    <title>My Blog | Posts</title>


</head><body class="light-theme"><div id="nav-border" class="container">
    <nav id="nav" class="nav justify-content-center">
        
        <a class="nav-link" href="/">
        
        
        <i data-feather="home"></i> 
        
        
        Home
        </a>
        
        <a class="nav-link" href="/tags/">
        
        
        <i data-feather="tag"></i> 
        
        
        Tags
        </a>
        
        <a class="nav-link" href="#" id="toggleDarkModeButton"><i data-feather="sun"></i></a>
        <span style="padding:5px"><input type="text" id="queryTextField"></span><a class="nav-link" href="#" id="searchButton"><i data-feather="search"></i></a>
    </nav>
</div><div id="content" style="margin:20px">
<h1>Posts</h1>

<p>
    <h3><a class="title" href="/posts/card/">Understanding the card table</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-04-17">Apr 17, 2021</time>

    <a class="summary" href="/posts/card/">
        <p>Understanding the card table A card table is used in a generational GC to discover cross-generational pointers. Let&rsquo;s get started with the generation GC problem first.
Generational GC It is observed allocations typically divides into two classes. Either they are short-lived or they are long lived. To efficiently use the memory, we would like to be able to reclaim the space of the short lived object relatively fast without having to worry about the long lived ones.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-6/">POH Tuning (Part 6 - Varying the benchmark)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-03-08">Mar 8, 2021</time>

    <a class="summary" href="/posts/poh-tuning-6/">
        <p>Varying the benchmark In the last post, we showed that in a particular scenario, allocating pinned objects on pinned object heap is a better choice from both the speed perspective and the heap size perspective. How about other scenarios?
In part 4, we already discussed the criterion what is feasible to test under GCPerfSim, so we will simply generate all the possibilities here with this simple Python script
for a in range(1, 100): if 1000 % a == 0: for b in range(1, a): if a % b == 0: if ((1000 - b) % (a - b) == 0): pin_sohsi = 1000 // a pin_sohpi = a // b poh_sohsi = (1000 - b) // (a - b) poh_pohar = b print(&#34; 2gb_pin_%s_%s:&#34; % (a, b)); print(&#34; arguments:&#34;); print(&#34; tc: 6&#34;); print(&#34; tagb: 100&#34;); print(&#34; tlgb: 2&#34;); print(&#34; lohar: 0&#34;); print(&#34; pohar: 0&#34;); print(&#34; sohsr: 100-4000&#34;); print(&#34; pohsr: 100-4000&#34;); print(&#34; sohsi: %s&#34; % pin_sohsi); print(&#34; lohsi: 0&#34;); print(&#34; pohsi: 0&#34;); print(&#34; sohpi: %s&#34; % pin_sohpi); print(&#34; lohpi: 0&#34;); print(&#34; sohfi: 0&#34;); print(&#34; lohfi: 0&#34;); print(&#34; pohfi: 0&#34;); print(&#34; allocType: reference&#34;); print(&#34; testKind: time&#34;); print(&#34; 2gb_poh_%s_%s:&#34; % (a, b)); print(&#34; arguments:&#34;); print(&#34; tc: 6&#34;); print(&#34; tagb: 100&#34;); print(&#34; tlgb: 2&#34;); print(&#34; lohar: 0&#34;); print(&#34; pohar: %s&#34; % poh_pohar); print(&#34; sohsr: 100-4000&#34;); print(&#34; pohsr: 100-4000&#34;); print(&#34; sohsi: %s&#34; % poh_sohsi); print(&#34; lohsi: 0&#34;); print(&#34; pohsi: 1&#34;); print(&#34; sohpi: 0&#34;); print(&#34; lohpi: 0&#34;); print(&#34; sohfi: 0&#34;); print(&#34; lohfi: 0&#34;); print(&#34; pohfi: 0&#34;); print(&#34; allocType: reference&#34;); print(&#34; testKind: time&#34;); Preprocessing the result As usual, we can create a pandas data frame for all the runs.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-5/">POH Tuning (Part 5 - Preliminary results)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-03-08">Mar 8, 2021</time>

    <a class="summary" href="/posts/poh-tuning-5/">
        <p>Top level result After running, we can use the Jupyter notebook to analyze the result. The result is surprising. To make the data easy to analyze, they are available as pandas data frame. For those who are unfamiliar with pandas, a data frame is really just a table.
To use the notebook to get to the data frame, we need to run the first cell (as it required to setup the functions), and then we can run the cell calling the get_test_metrics_numbers_for_jupyter function, there should be exactly one such cell.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-4/">POH Tuning (Part 4 - Benchmark design and the performance infrastructure)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-03-05">Mar 5, 2021</time>

    <a class="summary" href="/posts/poh-tuning-4/">
        <p>Benchmark design Armed with the knowledge about how the allocation ratios works in the previous post. Now we can design our benchmarks. My goal is to produce a pair of benchmarks so that I can compare pinning objects by using the old pinned handle, or by the new pinned object heap.
In the pinned handle case, we can have a general design like this:
Out of 1,000 objects in the SOH, \( a \) of them survives and \( b \) of them are pinned.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-3/">POH Tuning (Part 3 - Other statistical properties)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-03-01">Mar 1, 2021</time>

    <a class="summary" href="/posts/poh-tuning-3/">
        <p>In the last post, we discussed what the benchmark does and how the weights are computed. In this post, we will talk about some other interesting statistical properties. The lesson learned here is that we know how objects behave in the benchmark, and we can use this to judge whether or not the benchmark actually matches with real-life use cases.
Object lifetime In this previous post, we know about an object&rsquo;s life cycle.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-2/">POH Tuning (Part 2 - What am I running?)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-03-01">Mar 1, 2021</time>

    <a class="summary" href="/posts/poh-tuning-2/">
        <p>In the last post, we talk about the event tracing infrastructure, it allows us to measure the metrics we wanted to study when we run the program. But what program do we want to run? The program that we will run is called a benchmark. In this post, I will look into the details of the benchmark program.
Overview The program that we will run is called GCPerfSim. As its name suggests, it simulates workload for the GC to understand its performance.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-ordering-strings-of-varying-length-lexicographically/">Rosalind - Ordering Strings of Varying Length Lexicographically</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-02-14">Feb 14, 2021</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-ordering-strings-of-varying-length-lexicographically/">
        <p>Problem:
Please find the problem here. Solution:
I wanted to implement a solution that is analogous to an odometer. The key thing that we wanted to understand is how we can advance from the current word to the next one. Suppose we have the next function, then we can just repeatedly use that function to produce the next one. The next function would probably not work on the last element, so that will naturally provide us with a stopping condition as well.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-k-mer-composition/">Rosalind - k-Mer Composition</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-01-30">Jan 30, 2021</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-k-mer-composition/">
        <p>Problem:
Please find the problem here. Solution:
To produce the array, slide a window of width 4 from the leftmost to the rightmost of the string. When processing a window, we quickly compute the k-mer index as a base 4 number. Code:</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/debug-info-debugging/">Debug Info Debugging</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-01-18">Jan 18, 2021</time>

    <a class="summary" href="/posts/debug-info-debugging/">
        <p>Recently, I have found an anomaly in the debug info generated by the ready to run compiler. In this post, I will talk about how I found it and how I debugged it.
Discovery In a routine update of the ILCompiler.Reflection.ReadyToRun.dll for ILSpy, I turned on the STRESS mode I introduced in a recent commit to test whether or not the new version can disassemble all the methods in System.Private.CoreLib. To my surprise, it failed with this exception.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/poh-tuning-1/">POH Tuning (Part 1 - What is my pinned object heap size?)</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2021-01-15">Jan 15, 2021</time>

    <a class="summary" href="/posts/poh-tuning-1/">
        <p>In this series, I am going to talk about my work to tune the pinned object heap. The first step to tuning is to understand how it performs now. Unfortunately, the tools for analyzing the performance is incomplete.
Pinned Object Heap size (and the event tracing mechanisms) With the tools available in .NET 5 time frame, we did not know the size of the pinned object heap. We had the information in the trace, but we did not have the parser to understand them.</p>
    </a>
</p>

    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/10/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
        </div><p class="footer text-center">Copyright (c) 2026 Andrew Au</p><script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true });</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<script src="/js/feather.min.js"></script>
<script src="/index.js"></script>
<script>

  function getCookie(cname) {
    let name = cname + "=";
    let ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }

  function ensureIcon() {
    if (document.body.classList.contains("dark-theme")) {
      toggleDarkModeButton.innerHTML = '<i data-feather="sun"></i>';
    } else {
      toggleDarkModeButton.innerHTML = '<i data-feather="moon"></i>';
    }
    feather.replace();
  }
  function saveCookie() {
    if (document.body.classList.contains("dark-theme")) {
      setCookie("darkMode", "true", 365);
    } else {
      setCookie("darkMode", "false", 365);
    }
  }

  function load(pre) {
    link = pre.getAttribute("data-code-link");
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        pre.className = "prettyprint";
        pre.textContent = xhr.responseText;
      }
      prettyPrint();
    };
    xhr.open('GET', link);
    xhr.send();
  }

  function onSearchButtonClicked(e) {
    e.preventDefault();
    var query = $("#queryTextField").val();
    var terms = query.split(' ');
    
    var result = {};
    for (var i = 0; i < terms.length; ++i) {
      var term = terms[i].toLowerCase();
      if (term in index.Terms)
      {
        for (i = 0; i < index.Terms[term].length; i += 2) {
          var doc = index.Terms[term][i];
          var count = index.Terms[term][i + 1];
          if (doc in result) {
            result[doc] += count;
          } else {
            result[doc] = count;
          }
        }
      }
    }
    
    $("#content").empty();
    for (var key in result) {
      $("#content").append($('<a>', {
        href: index.Documents[key].replace("../../content","").replace(".md",""),
        text: index.Titles[key]
      }));
      $("#content").append($('<br>'));
    }
  }

  $(document).ready(function () {
    var darkMode = getCookie("darkMode");
    if (darkMode == "true") {
      document.body.classList.add("dark-theme");
      document.body.classList.remove("light-theme");
    }
    ensureIcon();

    $("#toggleDarkModeButton").click(function (e) {
      e.preventDefault();
      document.body.classList.toggle("dark-theme");
      document.body.classList.toggle("light-theme");
      saveCookie();
      ensureIcon();
    });

    $("#searchButton").click(onSearchButtonClicked);

    var pres = document.getElementsByTagName("pre");
    for (var i = 0; i < pres.length; ++i) {
      var pre = pres[i];
      if (pre.classList.contains("pretty-github-code")) {
        load(pre);
      }
    }
  });

  $(window).on("load", function () {
    $("body").show();
  });
</script></body>
</html>