<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/syntax.css">
    
    
    <title>My Blog | Posts</title>


</head><body class="light-theme"><div id="nav-border" class="container">
    <nav id="nav" class="nav justify-content-center">
        
        <a class="nav-link" href="/">
        
        
        <i data-feather="home"></i> 
        
        
        Home
        </a>
        
        <a class="nav-link" href="/tags/">
        
        
        <i data-feather="tag"></i> 
        
        
        Tags
        </a>
        
        <a class="nav-link" href="#" id="toggleDarkModeButton"><i data-feather="sun"></i></a>
        <span style="padding:5px"><input type="text" id="queryTextField"></span><a class="nav-link" href="#" id="searchButton"><i data-feather="search"></i></a>
    </nav>
</div><div id="content" style="margin:20px">
<h1>Posts</h1>

<p>
    <h3><a class="title" href="/posts/rosalind-introduction-to-set-operations/">Rosalind - Introduction to Set Operations</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-08">Sep 8, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-introduction-to-set-operations/">
        <p>Problem:
Please find the problem here.
Solution:
This is rather straightforward. By making the input sets hash tables, we can do these set operations fast.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-finding-a-spliced-motif/">Rosalind - Finding a Spliced Motif</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-08">Sep 8, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-finding-a-spliced-motif/">
        <p>Problem:
Please find the problem here.
Solution:
To find the corresponding indexes, we initialize two pointers to the beginning of both strings. Walk the sequence pointer one by one, and walk the subsequence pointer only when there is a match. This way we will find all the indexes.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-counting-subsets/">Rosalind - Counting Subsets</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-08">Sep 8, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-counting-subsets/">
        <p>Problem:
Please find the problem here.
Solution:
The number of subsets of a set of size \( n \) is \( 2^n \). The following code implements the repeated squaring algorithm. The numbers are computed modulo \( 1000000 \) as soon as we are done with multiplying. This is done to keep the number small, and so that the multiplications are quick.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-introduction-to-random-strings/">Rosalind - Introduction to Random Strings</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-08">Sep 8, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-introduction-to-random-strings/">
        <p>Problem:
Please find the problem here.
Solution:
As we were told in the description, the probability of getting &lsquo;A&rsquo; or &lsquo;T&rsquo; is \( \frac{1-x}{2} \) and the probability of getting &lsquo;G&rsquo; or &lsquo;C&rsquo; is \( \frac{x}{2} \). Assuming independence (sadly the problem does not mention that), the probability of the whole string is the product of these probabilities.
To make it numerically stable, instead of computing the product and then compute the logarithm, it is better to compute the logarithm and sum them up.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-genome-assembly-as-shortest-superstring/">Rosalind - Genome Assembly as Shortest Superstring</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-05">Sep 5, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-genome-assembly-as-shortest-superstring/">
        <p>Problem:
Please find the problem here.
Solution:
The condition that there exists a unique path in the overlap graph is super important. Once we have the overlap graph, the topological sort would be the right answer, because the path would guarantee there is a single answer.
Unlike the earlier problem Overlap Graphs, we do not know how long is the overlap. Therefore we need to be smart. We could try the overlap value, but that would lead to a quadratic algorithm.</p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-completing-a-tree/">Rosalind - Completing a Tree</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-01">Sep 1, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-completing-a-tree/">
        <p>Problem:
Please find the problem here.
Solution:
By iteratively eliminating leaves, it is easy to see that a tree of \( n \) nodes has \( n - 1 \) edges. Therefore the solution is simply computing \( (n - 1) \) - number of edges, which is also equal to \( n \) - number of lines. Remember the first line is the number of nodes :)
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-partial-permutations/">Rosalind - Partial Permutations</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-01">Sep 1, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-partial-permutations/">
        <p>Problem:
Please find the problem here.
Solution:
This is simply the permutation coefficient. All we need to do is to compute it.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-longest-increasing-subsequence/">Rosalind - Longest Increasing Subsequence</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-01">Sep 1, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-longest-increasing-subsequence/">
        <p>Problem:
Please find the problem here.
Solution:
This solution is based on dynamic programming, in particular, patience sorting. The code should explain in details how its work.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-enumerating-k-mers-lexicographically/">Rosalind - Enumerating k-mers Lexicographically</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-01">Sep 1, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-enumerating-k-mers-lexicographically/">
        <p>Problem:
Please find the problem here.
Solution:
The key to do this problem is to interpret these k-mers as an integer with the number of alphabets as a base. That way enumerating them lexicographically is simply looping.
Code:
 </p>
    </a>
</p>

<p>
    <h3><a class="title" href="/posts/rosalind-rna-splicing/">Rosalind - RNA Splicing</a></h3>
    

<i data-feather="calendar"></i>
<time datetime="2019-09-01">Sep 1, 2019</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://cshung.github.io/tags/rosalind">rosalind</a>


    <a class="summary" href="/posts/rosalind-rna-splicing/">
        <p>Problem:
Please find the problem here.
Solution:
I am lazy with this one. I could try my hands on the rope data structure, but I didn&rsquo;t. I simply reconstructed the string again and again on the splicing.
To implement this properly with the rope data structure is going to be challenging. In particular, I need to implement my own version of fast substring search on the rope data structure.
Code:</p>
    </a>
</p>

    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 6" class="page-link" role="button">6</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/7/" aria-label="Page 7" class="page-link" role="button">7</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/8/" aria-label="Page 8" class="page-link" role="button">8</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/7/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
        </div><p class="footer text-center">Copyright (c) 2023 Andrew Au</p><script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true });</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<script src="/js/feather.min.js"></script>
<script src="/index.js"></script>
<script>

  function getCookie(cname) {
    let name = cname + "=";
    let ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }

  function ensureIcon() {
    if (document.body.classList.contains("dark-theme")) {
      toggleDarkModeButton.innerHTML = '<i data-feather="sun"></i>';
    } else {
      toggleDarkModeButton.innerHTML = '<i data-feather="moon"></i>';
    }
    feather.replace();
  }
  function saveCookie() {
    if (document.body.classList.contains("dark-theme")) {
      setCookie("darkMode", "true", 365);
    } else {
      setCookie("darkMode", "false", 365);
    }
  }

  function load(pre) {
    link = pre.getAttribute("data-code-link");
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        pre.className = "prettyprint";
        pre.textContent = xhr.responseText;
      }
      prettyPrint();
    };
    xhr.open('GET', link);
    xhr.send();
  }

  function onSearchButtonClicked(e) {
    e.preventDefault();
    var query = $("#queryTextField").val();
    var terms = query.split(' ');
    
    var result = {};
    for (var i = 0; i < terms.length; ++i) {
      var term = terms[i].toLowerCase();
      if (term in index.Terms)
      {
        for (i = 0; i < index.Terms[term].length; i += 2) {
          var doc = index.Terms[term][i];
          var count = index.Terms[term][i + 1];
          if (doc in result) {
            result[doc] += count;
          } else {
            result[doc] = count;
          }
        }
      }
    }
    
    $("#content").empty();
    for (var key in result) {
      $("#content").append($('<a>', {
        href: index.Documents[key].replace("../../content","").replace(".md",""),
        text: index.Titles[key]
      }));
      $("#content").append($('<br>'));
    }
  }

  $(document).ready(function () {
    var darkMode = getCookie("darkMode");
    if (darkMode == "true") {
      document.body.classList.add("dark-theme");
      document.body.classList.remove("light-theme");
    }
    ensureIcon();

    $("#toggleDarkModeButton").click(function (e) {
      e.preventDefault();
      document.body.classList.toggle("dark-theme");
      document.body.classList.toggle("light-theme");
      saveCookie();
      ensureIcon();
    });

    $("#searchButton").click(onSearchButtonClicked);

    var pres = document.getElementsByTagName("pre");
    for (var i = 0; i < pres.length; ++i) {
      var pre = pres[i];
      if (pre.classList.contains("pretty-github-code")) {
        load(pre);
      }
    }
  });

  $(window).on("load", function () {
    $("body").show();
  });
</script></body>
</html>