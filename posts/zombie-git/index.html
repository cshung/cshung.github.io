<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/syntax.css">
    
    
    <title>My Blog | Hunting Zombie Processes: From 6,500 Zombies to a Bug in Git</title>


</head><body class="light-theme"><div id="nav-border" class="container">
    <nav id="nav" class="nav justify-content-center">
        
        <a class="nav-link" href="/">
        
        
        <i data-feather="home"></i> 
        
        
        Home
        </a>
        
        <a class="nav-link" href="/tags/">
        
        
        <i data-feather="tag"></i> 
        
        
        Tags
        </a>
        
        <a class="nav-link" href="#" id="toggleDarkModeButton"><i data-feather="sun"></i></a>
        <span style="padding:5px"><input type="text" id="queryTextField"></span><a class="nav-link" href="#" id="searchButton"><i data-feather="search"></i></a>
    </nav>
</div><div id="content" style="margin:20px">
<h1>Hunting Zombie Processes: From 6,500 Zombies to a Bug in Git</h1>


<i data-feather="calendar"></i>
<time datetime="2026-02-23">Feb 23, 2026</time>

<br><br>
<h2 id="the-discovery">The Discovery</h2>
<p>It started with an expired access token. I was trying to <code>git fetch</code> in one of my repos and got an authentication failure. While poking around, I noticed something odd — thousands of zombie processes on my machine:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ ps aux | grep -w Z | wc -l
</span></span><span class="line"><span class="cl">6530
</span></span></code></pre></div><p>Over six thousand zombies, all <code>[git]</code> and <code>[ssh]</code> defunct processes. Every single one parented by the same PID — the <code>houndd</code> process running inside a Docker container.</p>
<p><a href="https://github.com/hound-search/hound">Hound</a> is a code search tool. It periodically runs <code>git fetch</code> to keep its indexed repositories up to date. Two of my configured repositories pointed to Azure DevOps with an expired token, so every fetch attempt was failing. And every failure was leaking a zombie.</p>
<h2 id="understanding-the-setup">Understanding the Setup</h2>
<p>Hound runs as PID 1 inside its Docker container. This is important — when a process&rsquo;s parent exits, the orphaned child gets re-parented to PID 1. If PID 1 doesn&rsquo;t call <code>wait()</code> on adopted children, they become zombies.</p>
<p>The hound Go code spawns git in several places:</p>
<ul>
<li><code>run()</code> — uses <code>exec.Command().CombinedOutput()</code> for <code>git fetch</code>, <code>git reset</code>, <code>git remote show</code></li>
<li><code>HeadRev()</code> — uses <code>cmd.Start()</code> + <code>cmd.Wait()</code> for <code>git rev-parse</code></li>
<li><code>Clone()</code> — uses <code>cmd.CombinedOutput()</code> for <code>git clone</code></li>
<li><code>AutoGeneratedFiles()</code> — uses <code>cmd.Start()</code> + <code>cmd.Wait()</code> for <code>git ls-files</code> and <code>git check-attr</code></li>
</ul>
<p>There was already a fix attempt on the <code>fix/zombie-processes</code> branch that added <code>cmd.Wait()</code> calls to error paths in <code>HeadRev()</code> and <code>AutoGeneratedFiles()</code>. The fix was deployed. But the zombies kept coming — about 4 per minute.</p>
<h2 id="first-theory-missing-wait-in-hound">First Theory: Missing Wait() in Hound</h2>
<p>The natural assumption was that hound&rsquo;s Go code wasn&rsquo;t properly waiting on some git child processes. <code>CombinedOutput()</code> internally calls <code>Wait()</code>, so those paths should be safe. The fix addressed <code>HeadRev()</code> and <code>AutoGeneratedFiles()</code>, but maybe there were other leak paths?</p>
<p>To find out which process was actually becoming a zombie, I needed to intercept every git invocation.</p>
<h2 id="the-git-proxy">The Git Proxy</h2>
<p>To catch every git invocation — whether from hound&rsquo;s Go code or from git&rsquo;s own internal subprocesses — I built a proxy binary:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">self</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Readlink</span><span class="p">(</span><span class="s">&#34;/proc/self/exe&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">realGit</span> <span class="o">:=</span> <span class="nx">self</span> <span class="o">+</span> <span class="s">&#34;.real&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">os</span><span class="p">.</span><span class="nf">MkdirAll</span><span class="p">(</span><span class="s">&#34;/srv/hound/git-proxy-logs&#34;</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pid</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;/srv/hound/git-proxy-logs/%d.log&#34;</span><span class="p">,</span> <span class="nx">pid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="s">&#34;pid=%d cmd=%s %s\n&#34;</span><span class="p">,</span> <span class="nx">pid</span><span class="p">,</span> <span class="nx">self</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s">&#34; &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">syscall</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">realGit</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Key design decisions:</p>
<ul>
<li><strong><code>syscall.Exec</code></strong> replaces the proxy process with real git — same PID, same parent, no interference with git&rsquo;s stdout/stderr</li>
<li><strong>Log to files, not stderr</strong> — hound depends on git&rsquo;s output; we can&rsquo;t pollute it</li>
<li><strong>Per-PID filenames</strong> — no contention between concurrent git processes</li>
<li><strong><code>/proc/self/exe</code></strong> to resolve the real path — because <code>argv[0]</code> might just be <code>&quot;git&quot;</code> without a path</li>
</ul>
<p>I replaced both <code>/usr/bin/git</code> and <code>/usr/lib/git-core/git</code> with the proxy (renaming the originals to <code>*.real</code>), rebuilt the container to run as root (to have permission to replace system binaries), and deployed.</p>
<h2 id="the-breakthrough">The Breakthrough</h2>
<p>After letting it run and accumulate zombies, I matched zombie PIDs to log files. The PIDs needed translation — <code>ps</code> shows host-namespace PIDs, but the proxy logs container-namespace PIDs. The mapping lives in <code>/proc/&lt;pid&gt;/status</code> under <code>NSpid</code>.</p>
<p>The result was unambiguous:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">host=2783115 container=87 comm=git.real log=pid=87 cmd=/usr/lib/git-core/git remote-https origin https://&lt;redacted&gt;
</span></span><span class="line"><span class="cl">host=2783237 container=170 comm=git.real log=pid=170 cmd=/usr/lib/git-core/git remote-https origin https://&lt;redacted&gt;
</span></span><span class="line"><span class="cl">host=2783495 container=354 comm=git.real log=pid=354 cmd=/usr/lib/git-core/git remote-https origin https://&lt;redacted&gt;
</span></span></code></pre></div><p>Every zombie was <code>git remote-https</code> — the HTTPS transport helper. When hound runs <code>git fetch</code>, git spawns <code>git remote-https</code> as a child to handle the HTTPS protocol. When authentication fails, <code>git fetch</code> exits, but its <code>git remote-https</code> child hasn&rsquo;t been waited on. The orphaned child gets re-parented to PID 1 (houndd), and since houndd doesn&rsquo;t reap adopted children, it becomes a zombie.</p>
<h2 id="the-root-cause-in-git">The Root Cause in Git</h2>
<p>With the smoking gun pointing at <code>git remote-https</code>, I cloned git&rsquo;s source (v2.39.5 to match the container). The zombie was a transport helper, and there&rsquo;s a file literally called <code>transport-helper.c</code> — that&rsquo;s where I started looking.</p>
<p>Inside, <code>get_helper()</code> is the function that spawns the helper process. Confirming this is the right place, line 139 constructs the command name:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">strvec_pushf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">helper</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">,</span> <span class="s">&#34;remote-%s&#34;</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span></span></code></pre></div><p>When fetching over HTTPS, <code>data-&gt;name</code> is <code>&quot;https&quot;</code>, producing <code>remote-https</code>. Combined with <code>helper-&gt;git_cmd = 1</code> (which tells <code>start_command</code> to run it as a git subcommand), this is exactly what spawns <code>/usr/lib/git-core/git remote-https</code> — our zombie.</p>
<p>The helper is started a few lines later:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">code</span> <span class="o">=</span> <span class="nf">start_command</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>
</span></span></code></pre></div><p>Since <code>start_command()</code> forks the child, there must be a matching <code>waitpid()</code> somewhere. In git&rsquo;s codebase, that&rsquo;s wrapped in <code>finish_command()</code>. Grepping for <code>finish_command</code> in the file finds exactly one call — inside <code>disconnect_helper()</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">disconnect_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">transport</span> <span class="o">*</span><span class="n">transport</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">res</span> <span class="o">=</span> <span class="nf">finish_command</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">);</span>  <span class="c1">// calls waitpid()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">FREE_AND_NULL</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>So <code>disconnect_helper()</code> is the only place the helper gets reaped. The next question is: does every code path reach it? Searching for <code>exit(</code> in the file reveals the answer — no. There are at least 6 <code>exit(128)</code> calls scattered across the file:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">recvline</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>  <span class="c1">// helper child is never waited on!
</span></span></span></code></pre></div><p>When <code>git remote-https</code> reports an authentication failure, <code>recvline()</code> fails (the helper&rsquo;s output pipe closes), and git calls <code>exit(128)</code> directly — never going through <code>disconnect_helper()</code>, never calling <code>finish_command()</code>, never calling <code>waitpid()</code>.</p>
<h2 id="why-atexit">Why <code>atexit</code></h2>
<p>One approach would be to patch each <code>exit(128)</code> site to call <code>disconnect_helper(transport)</code> first. But this has problems:</p>
<ul>
<li>It&rsquo;s error-prone — miss one and you still have zombies</li>
<li>Some of those <code>exit()</code> sites don&rsquo;t have <code>transport</code> in scope, so threading it through would be invasive</li>
<li>Future code could add new <code>exit()</code> calls without knowing about the cleanup requirement</li>
</ul>
<p>Instead, I used an <code>atexit</code> handler — a safety net that catches <em>all</em> exit paths with zero changes to existing control flow. Git itself uses this pattern in several places, most notably in <code>run-command.c</code> where <code>cleanup_children_on_exit</code> is registered via <code>atexit</code> to kill and reap child processes on abnormal exit, with <code>clear_child_for_cleanup</code> to deregister them on normal cleanup. The same pattern applies here — register the helper for reaping, clear it when properly disconnected.</p>
<h2 id="the-fix">The Fix</h2>
<p>The fix is an <code>atexit</code> handler:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">child_process</span> <span class="o">*</span><span class="n">helper_to_reap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_helper_on_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">helper_to_reap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">finish_command</span><span class="p">(</span><span class="n">helper_to_reap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Registered right after the helper starts:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">data</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">helper_to_reap</span> <span class="o">=</span> <span class="n">helper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">atexit</span><span class="p">(</span><span class="n">cleanup_helper_on_exit</span><span class="p">);</span>
</span></span></code></pre></div><p>And cleared on normal cleanup:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">res</span> <span class="o">=</span> <span class="nf">finish_command</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">helper_to_reap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// atexit handler becomes a no-op
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">FREE_AND_NULL</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">helper</span><span class="p">);</span>
</span></span></code></pre></div><p>This catches all the <code>exit(128)</code> paths without modifying any of them. The <code>atexit</code> handler runs during process teardown and reaps the transport helper child.</p>
<p>The normal cleanup path and the <code>atexit</code> handler do not conflict. On the normal path, <code>disconnect_helper()</code> calls <code>finish_command()</code> to reap the child, then sets <code>helper_to_reap = NULL</code>. When the process eventually exits, the <code>atexit</code> handler sees <code>NULL</code> and does nothing. On the error path, <code>exit(128)</code> is called without going through <code>disconnect_helper()</code>, so <code>helper_to_reap</code> is still set, and the <code>atexit</code> handler reaps the child.</p>
<p>The same pattern applies to <code>connect.c</code>, where <code>finish_connect()</code> can be bypassed when callers <code>die()</code> or <code>exit()</code> before reaching it. An identical atexit handler ensures the SSH or proxy child is reaped.</p>
<h2 id="verification">Verification</h2>
<h3 id="https-transport-transport-helperc">HTTPS transport (<code>transport-helper.c</code>)</h3>
<p>I built the patched git inside a <code>debian:bookworm</code> container (matching the target environment to avoid glibc mismatches), deployed it, and watched:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">=== Zombies after 2 minutes ===
</span></span><span class="line"><span class="cl">0
</span></span></code></pre></div><p>Zero zombies, despite continuous authentication failures on two repositories every 15 seconds.</p>
<h3 id="ssh-transport-connectc">SSH transport (<code>connect.c</code>)</h3>
<p>To verify the connect.c fix independently, I used a red/green approach:</p>
<ol>
<li><strong>Red (before fix):</strong> Built the hound image with git patched only in <code>transport-helper.c</code> (no <code>connect.c</code> atexit handler). Hid SSH keys (<code>mv ~/.ssh ~/.ssh_hidden</code>) to force SSH authentication failures. Within seconds, SSH zombies accumulated:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ ps aux | grep defunct
</span></span><span class="line"><span class="cl">user     3253967  [ssh] &lt;defunct&gt;
</span></span><span class="line"><span class="cl">user     3253977  [ssh] &lt;defunct&gt;
</span></span><span class="line"><span class="cl">user     3254057  [ssh] &lt;defunct&gt;
</span></span><span class="line"><span class="cl">user     3254063  [ssh] &lt;defunct&gt;
</span></span><span class="line"><span class="cl">user     3254069  [ssh] &lt;defunct&gt;
</span></span></code></pre></div><p>All parented to houndd (PID 1 in the container), confirming the <code>finish_connect()</code> path was being bypassed on <code>exit(128)</code>.</p>
<ol start="2">
<li><strong>Green (after fix):</strong> Rebuilt git with the <code>connect.c</code> atexit handler, rebuilt the hound image, and restarted the container — still with SSH keys hidden. The same SSH failures occurred (<code>Host key verification failed</code>, exit status 128), but:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ ps aux | grep defunct | grep -v grep | wc -l
</span></span><span class="line"><span class="cl">0
</span></span></code></pre></div><p>Zero zombies. The atexit handler in <code>connect.c</code> successfully reaps the ssh child process on abnormal exit.</p>
<h2 id="lessons-learned">Lessons Learned</h2>
<ol>
<li>
<p><strong>Zombie processes are always about <code>waitpid()</code></strong> — but the question is <em>who</em> should be calling it and <em>which child</em> isn&rsquo;t being waited on.</p>
</li>
<li>
<p><strong>PID 1 matters in containers.</strong> Most programs aren&rsquo;t designed to be PID 1. When they are, orphaned grandchildren become their responsibility. This is why <code>docker run --init</code> (which uses <code>tini</code> as PID 1) exists.</p>
</li>
<li>
<p><strong>The obvious suspect isn&rsquo;t always the culprit.</strong> The initial fix targeted hound&rsquo;s Go code, but the real bug was in git itself. The git proxy approach was what finally revealed the truth.</p>
</li>
<li>
<p><strong>Process names in <code>ps</code> tell you less than you think.</strong> Zombie processes lose their <code>/proc/&lt;pid&gt;/cmdline</code>. The <code>comm</code> field survives, but it&rsquo;s just the executable name — not the arguments. We needed the proxy&rsquo;s log files to see the full picture.</p>
</li>
<li>
<p><strong>Namespace translation is essential for container debugging.</strong> Host PIDs and container PIDs are different. <code>/proc/&lt;pid&gt;/status</code> with <code>NSpid</code> is the bridge.</p>
</li>
</ol>
<h2 id="resolution">Resolution</h2>
<p>Both transport paths are now fixed and verified:</p>
<ul>
<li><strong>HTTPS</strong>: <code>transport-helper.c</code> — atexit handler reaps <code>git-remote-https</code></li>
<li><strong>SSH/proxy/local</strong>: <code>connect.c</code> — atexit handler reaps the connection child</li>
</ul>
<p>The fix is available on <a href="https://github.com/cshung/git/tree/fix/zombie-reap-on-exit">GitHub</a> and has been <a href="https://lore.kernel.org/git/20260223165147.3294516-1-cshung@gmail.com/">submitted to the Git mailing list</a>. The bug exists in git&rsquo;s current <code>master</code> branch as of February 2026.</p>


        </div><p class="footer text-center">Copyright (c) 2026 Andrew Au</p><script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true });</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<script src="/js/feather.min.js"></script>
<script src="/index.js"></script>
<script>

  function getCookie(cname) {
    let name = cname + "=";
    let ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }

  function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }

  function ensureIcon() {
    if (document.body.classList.contains("dark-theme")) {
      toggleDarkModeButton.innerHTML = '<i data-feather="sun"></i>';
    } else {
      toggleDarkModeButton.innerHTML = '<i data-feather="moon"></i>';
    }
    feather.replace();
  }
  function saveCookie() {
    if (document.body.classList.contains("dark-theme")) {
      setCookie("darkMode", "true", 365);
    } else {
      setCookie("darkMode", "false", 365);
    }
  }

  function load(pre) {
    link = pre.getAttribute("data-code-link");
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        pre.className = "prettyprint";
        pre.textContent = xhr.responseText;
      }
      prettyPrint();
    };
    xhr.open('GET', link);
    xhr.send();
  }

  function onSearchButtonClicked(e) {
    e.preventDefault();
    var query = $("#queryTextField").val();
    var terms = query.split(' ');
    
    var result = {};
    for (var i = 0; i < terms.length; ++i) {
      var term = terms[i].toLowerCase();
      if (term in index.Terms)
      {
        for (i = 0; i < index.Terms[term].length; i += 2) {
          var doc = index.Terms[term][i];
          var count = index.Terms[term][i + 1];
          if (doc in result) {
            result[doc] += count;
          } else {
            result[doc] = count;
          }
        }
      }
    }
    
    $("#content").empty();
    for (var key in result) {
      $("#content").append($('<a>', {
        href: index.Documents[key].replace("../../content","").replace(".md",""),
        text: index.Titles[key]
      }));
      $("#content").append($('<br>'));
    }
  }

  $(document).ready(function () {
    var darkMode = getCookie("darkMode");
    if (darkMode == "true") {
      document.body.classList.add("dark-theme");
      document.body.classList.remove("light-theme");
    }
    ensureIcon();

    $("#toggleDarkModeButton").click(function (e) {
      e.preventDefault();
      document.body.classList.toggle("dark-theme");
      document.body.classList.toggle("light-theme");
      saveCookie();
      ensureIcon();
    });

    $("#searchButton").click(onSearchButtonClicked);

    var pres = document.getElementsByTagName("pre");
    for (var i = 0; i < pres.length; ++i) {
      var pre = pres[i];
      if (pre.classList.contains("pretty-github-code")) {
        load(pre);
      }
    }
  });

  $(window).on("load", function () {
    $("body").show();
  });
</script></body>
</html>